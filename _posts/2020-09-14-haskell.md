---
title: Setting up a Haskell Project    
tags: code fp haskell
---

In what follows we will set up a simple project using
`stack` and see how to run code in the project using
`ghci`, Haskell's interactive read-eval-print loop (repl).
This program will print a message on the screen.  Next,
we develop a program prints a random
integer to the screen.  This will be done using
`randomIO` in the `System.Random` module.  To use `System.Random`,
we must find the package in which it is defined.
We'll do this using [Hackage](https://hackage.haskell.org/), a
search tool for packages. The next steps are


-  Reference the package for `System.Random` in `package.yaml`.

- Use `ghci` to run `randomIO`.

- Modify the program so that it prints out a random
integer.

- Compile the program, again
using stack.

- Run the program from the command line.

In the appendix, we analyze the types used in the program and show how
another search tool, `Hoogle`, can be used to find a type
signature from a function name or a function name from
a type signature.

## Initial setup

We will run `stack new randomStuff` to start
a new project named *randomStuff*.  This will set
up a project with the file
`./app/Main.hs` which looks like this:

```
module Main where

import Lib

main :: IO ()
main = someFunc
```

If we look at `.src/Lib.h`, we find the below:

```
module Lib ( someFunc ) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

Thus, running the program `Main.hs` should
print "someFunc".   Let's set things up now:


```
$ stack new randomStuff
$ stack ghci
*Main Lib> main
someFunc
```

Success!

## Adding a package

We are going to add code to our program so that
it prints out a random number.  For this we
will use the module `System.Random`.  We'll
need to find the name of the package that
exposes this module.  There are two good ways to
do this

- Google "haskell System.Random",
we find [this page](https://hackage.haskell.org/package/random-1.2.0/docs/System-Random.html)

- Go to [Hackage](https://hackage.haskell.org/) and type "System.Random" in
the search box.


Either way, if look closely at the fine print at the top, we find the text

```
random-1.2.0: Pseudo-random number generation
```

This is our clue.  So we put the line `- random` in the file `package.yaml`
in just the right place, like so:

```
dependencies:
- base >= 4.7 && < 5
- random -- << NEW TEXT
```

Then we change `Main.hs` so that it looks like this:

```
module Main where

import Lib
import System.Random

main :: IO ()
main = someFunc

newRand = randomIO :: IO Int
```

Thus, we have imported the module `System.Random`
and used it to define `newRand`.  Before proceeding
further, we test to see if this works:

```
$ stack ghci

*Main Lib> newRand
1095906040554822953

*Main Lib> newRand
2091178867183333176
```

Yes!  Making progress.

**Note.** When you change code but are still in `ghci`,
you can type `:reload` (or just `:r`) to reload the code.

## Finishing the program

We've tested `randomIO`, and it works.  But we
would like to fully integrate it into our program
so that when we run the program, it prints
a random number to the screen.  Below is
one solution.

```
module Main where

import System.Random

main :: IO ()
main = newRand >>= print

newRand = randomIO :: IO Int
```

Next, we reload `ghci` and run `main`:

```
> :reload
Ok, two modules loaded.
> main
-3910396880313191658
```

The last step is to compile our program and run it in the terminal:

```
$ stack build
...

$ ./app/Main
664397062957259411

$ ./app/Main
-1747843471900380854
```

When we ran `stack build`, stack ran `ghc` on `./app/Main.hs` and
produced the executable file `./app/Main`, which we ran from the
command line to produce a "random" integer.

## Appendix: Understanding the Program

To understand the program, we need to understand how the  
types fit together.  Our explanation is a bit long, but
it has several benefits. The first is that understanding
basic principles helps us to better create our own
code, rather than relying on copy-paste.  Second is
that we will learn to use another valuable tool,
[Hoogle](https://hoogle.haskell.org/).  It is
a search tool for functions and values.  

Let's begin by putting `main` in
the search box, of Hoogle. We find that `main : IO ()`.  That is, `main` has type `IO ()`.
Thus, if we say `main = whatever`, then `whatever` must also have type `IO ()`.

Let's look next at `newRand`.  It has type `IO Int`,
and if search for `print` using Hoogle, we find
this:

```
Show a => a -> IO ()
```

What this means is that `print`  has type `a -> IO a`,
but where `a` is constrained to be of typeclass `Show a`.  Things of typeclass `Show a` are printable.  

At this point we have something
of type `IO Int` and a function of type `a -> IO ()`, which in our
context is of  type `Int -> IO ()`. From these, we want
to produce something of type  `IO ()`.  Suppose we had a
function `op` that could do the job, so that

```
newRand `op` print :: IO ()
```

This is the same as having a function `(op)` such that


```
(op) newRand print :: IO ()
```

Therefore `(op)` has signature

```
IO Int -> (Int -> IO ()) -> IO ()
```

This signature is an instance of the general pattern

```
m a -> (a -> m ()) -> m ()
```

where `m = IO` and `a = Int`.  And this last type
signature is an instance of the still more general

```
m a -> (a -> m b) -> m b
```

There is indeed a function of this type: the *bind* operator
`>>=`.  Indeed, if we put that type into Hoogle, we Find

```
(>>=) :: forall a b . Monad m => m a -> (a -> m b) -> m b
```


## References

- [Hackage](https://hackage.haskell.org/) — search for libraries, packages

- [Hoogle](https://hoogle.haskell.org/) — search for functions and type signatures
